<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>blog.smigiel.dev | Articles by dasm</title>
    <link rel="shortcut icon" type="image/png" href="https://blog.smigiel.dev/favicon.png">
    <link rel="shortcut icon" type="image/x-icon" href="https://blog.smigiel.dev/favicon.ico">
    <link href="https://blog.smigiel.dev/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="blog.smigiel.dev Full Atom Feed" />
    <link rel="stylesheet" href="https://blog.smigiel.dev/theme/css/main.css" type="text/css" />
    <link rel="stylesheet" href="https://blog.smigiel.dev/theme/css/pygments.css" type="text/css" />
    <meta name="generator" content="Pelican" />
    <meta name="description" content="" />
    <meta name="author" content="dasm" />
</head>
<body>
    <header>
        <nav>
            <ul>

                <li class="ephemeral selected"><a href="https://blog.smigiel.dev/author/dasm.html">dasm</a></li>
                <li><a href="https://blog.smigiel.dev/">Home</a></li>
                <li><a href="https://blog.smigiel.dev/pages/about-me.html">About me</a></li>
                <li><a href="https://blog.smigiel.dev/pages/resources.html">Resources</a></li>
                <li><a href="https://blog.smigiel.dev/archives">Archives</a></li>
            </ul>
        </nav>
        <div class="header_box">
            <h1><a href="https://blog.smigiel.dev/">blog.smigiel.dev</a></h1>
        </div>
    </header>
    <div id="wrapper">
        <div id="content">            <h4 class="date">Feb 05, 2021</h4>

            <article class="post">
                <h2 class="title">
                    <a href="https://blog.smigiel.dev/introduction-to-the-cloud.html" rel="bookmark" title="Permanent Link to &quot;Introduction to the Cloud&quot;">Introduction to the Cloud</a>
                </h2>

                
                

                <p>This post is an attempt to gather common terms, and provide links for more reading (mainly to wikipedia) about virtualization et al.</p>
<h1>Intro</h1>
<p>Virtualization term has been coined in 1960s to describe virtual machine. Right now, virtualization can also describe other areas like: software, memory, storage, data, network and hardware.
However, in the common understanding, virtualization means hardware virtualization. It refers to the creation of virtual machine htat acts like a real computer with an operating system.</p>
<h1>Hardware virtualization</h1>
<p><a href="https://en.wikipedia.org/wiki/Hardware_virtualization">Hardware Virtualization</a> can be divided into two main types:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Full_virtualization">full virtualization</a> - completely simulates the actual hardware, guest system can run unmodified.</li>
<li><a href="https://en.wikipedia.org/wiki/Paravirtualization">paravirtualization</a> - uses software interface which is similar, but not identical to the underlying hardware.</li>
</ul>
<h2>Full virtualization</h2>
<p>Virtual machine simulates hardware to allow an unmodified guest OS to be run in isolation.</p>
<ul>
<li>Software-assisted - completely relies on binary translation to virtualize the execution of sensitive, non-virtualizable instruction sets. It emulates the hardware using the software instruction sets. Due to binary translation, it is often criticized for performance issue: Eg. VirtualBox, VMware workstation, Virtual PC</li>
<li>Hardware-assisted - it eliminates the binary translation and it directly interrupts with hardware using the virtualization technology which has been integrated on processors. Guest OS's instructions might allow a virtual context execute privileged instructions directly on the processor, even thought it is virtualized. Eg. VMware ESXi, KVM, Hyper-V, Xen.</li>
</ul>
<h2>Paravirtualization</h2>
<p>It requires the guest operating system to be explicitly ported for the para-API, conventional OS distribution that is not paravirtualization-aware cannot be run on top of a paravirtualizing VVM.</p>
<h1>Hypervisor</h1>
<p><a href="https://en.wikipedia.org/wiki/Hypervisor">Hypervisor</a> (virtual machine monitor, VMM) is computer software, firmare or hardware that runs virtual machines. A computer on which a hypervisor runs one or more virtual machines is called a <em>host machine</em>, and each virtual machine is called a <em>guest machine</em>.
There are two types of hypervisors:</p>
<ul>
<li>Type-1, native or bare-metal hypervisors</li>
<li>Type-2 or hosted hypervisors</li>
</ul>
<h2>Type-1 (bare-metal)</h2>
<p>Type-1 hypervisor is very basic OS on top of which there can be run virtual machines. The physical machine the hypervisor is running on serves virtualization purpose only. It is mainly found in enterprise environments.
Due to its simplicity, it doesn't offer many functionalities.
Examples:</p>
<ul>
<li>VMware ESX/ESXi</li>
<li>KVM (it oftentimes can be categorized as type-2 hypervisor)</li>
<li>Oracle VM</li>
</ul>
<h2>Type-2 (hosted)</h2>
<p>This type of hypervisor runs on a conventional OS as an another program.
Examples:</p>
<ul>
<li>VirtualBox</li>
<li>VMware Workstation</li>
<li>Windows Virtual PC</li>
<li>Parallels Desktop</li>
</ul>
                <div class="clear"></div>

                <div class="info">
                    <a href="https://blog.smigiel.dev/introduction-to-the-cloud.html">posted at 00:00</a>
                    &nbsp;&middot;
                    &nbsp;<a href="https://blog.smigiel.dev/tag/learning.html" class="tags">learning</a>
                    &nbsp;<a href="https://blog.smigiel.dev/tag/virtualization.html" class="tags">virtualization</a>
                    &nbsp;<a href="https://blog.smigiel.dev/tag/cloud.html" class="tags">cloud</a>
                </div>
            </article>            <h4 class="date">Nov 20, 2020</h4>

            <article class="post">
                <h2 class="title">
                    <a href="https://blog.smigiel.dev/scanning-network.html" rel="bookmark" title="Permanent Link to &quot;Scanning Network&quot;">Scanning Network</a>
                </h2>

                
                

                <h1>Mapping a Network</h1>
<p>Sometimes, instead of receiving full information about target machines, penetration tester gets just address block. Later on, pentester needs to discover what kind of hosts with what kind of configuration, exist in particular network.</p>
<p>There are several different ways to reveal network configuration.</p>
<h2>PING sweeping</h2>
<p>Ping works by sending one or more special ICMP packets (type 8 - <strong>echo request</strong>) to a host. If the host replies with ICMP <strong>echo reply</strong> packets, it means that host is alive. <a href="https://tools.ietf.org/html/rfc792">RFC792</a> describes protocol used to carry diagnostic messages. ICMP is a part of the Internet Protocol.</p>
<h3>fping</h3>
<p><code>fping</code> is a Linux tool, improved version of standard <code>ping</code>. It can be run against IP range:</p>
<div class="highlight"><pre><span></span><code><span class="err">fping -a -g &lt;ip_range&gt; 2&gt;/dev/null # -a -- show alive; -g -- generate list, redirect to /dev/null to surpress noise.</span>
</code></pre></div>


<h3>nmap</h3>
<p>Recommended tool for penetration testing is <code>nmap</code>. It is very powerful tool, which allows for detection hosts, its systems and more.
To attempt port sweeping (ping scan), one can use <code>-sn</code> option:</p>
<div class="highlight"><pre><span></span><code><span class="err">nmap -sn &lt;ip_range&gt;</span>
</code></pre></div>


<h2>OS Fingerprinting</h2>
<p>After finishing <code>nmap</code> run, we end up having list of live hosts, responding to ping. Next, we need to understand what kind of operating system is used by a host. Based on differences in network stack implementation of the various operating systems, automated programs can analyze response, and recognize OS version, creating host signatures.</p>
<p>During a penetration test, person needs to perform reconnaissance step on <em>every network node</em>:</p>
<ul>
<li>routers</li>
<li>firewalls</li>
<li>hosts</li>
<li>servers</li>
<li>printers</li>
<li>etc</li>
</ul>
<p>The goal is to create table of nodes, with appropriate information about systems.</p>
<h3>Offline fingerprinting (p0f)</h3>
<p>For offline fingerprinting, one can use <code>p0f</code> tool to analyze dump of network traffic.</p>
<h3>Online fingerprinting (nmap)</h3>
<p>In a case of online, to go tool is again <code>nmap</code>.
To perform OS fingerprinting with it, you have to use <code>-O</code> option and specify target. In a case of known targets, you can add <code>-Pn</code> to skip rediscovering them again.</p>
<div class="highlight"><pre><span></span><code><span class="err">nmap -Pn -O &lt;targets&gt;</span>
</code></pre></div>


<p>This option can be additionally fine-tuned, to prevent from too aggressive way of discovering hosts:</p>
<div class="highlight"><pre><span></span><code><span class="err">OS DETECTION:</span>
<span class="err">  -O: Enable OS detection</span>
<span class="err">  --osscan-limit: Limit OS detection to promising targets</span>
<span class="err">  --osscan-guess: Guess OS more aggressively</span>
</code></pre></div>


<h2>Port Scanning</h2>
<p>After recognizing nodes and detecting operating systems, we can continue with port scanning. It allows to discover the daemons and services running on those nodes.</p>
<p>Port scanning is a process used to determine what TCP and UDP ports are open on target hosts. It, also usually helps detect which software and version is listening on a specific port.</p>
<h3>TCP Three-Way Handshake</h3>
<p>Default usage:</p>
<div class="highlight"><pre><span></span><code><span class="err">nmap -sT &lt;target&gt;</span>
</code></pre></div>


<p>Description of process.</p>
<div class="highlight"><pre><span></span><code><span class="n">Client</span> <span class="o">---</span> <span class="n">SYN</span> <span class="o">---&gt;</span> <span class="n">Server</span>
<span class="n">Client</span> <span class="o">&lt;-</span> <span class="n">SYN</span><span class="o">+</span><span class="n">ACK</span> <span class="o">-</span> <span class="n">Server</span>
<span class="n">Client</span> <span class="o">---</span> <span class="n">ACK</span> <span class="o">---&gt;</span> <span class="n">Server</span>
</code></pre></div>


<p>Client wants to connect to a server, it first sends a packet with the <code>SYN</code> flag enabled. The server then responds by sending a packet with both <code>SYN</code> and <code>ACK</code> flags enabled. Finally, the client replies back by sending a packet with the <code>ACK</code> flag enabled and the actual data transmission can start.</p>
<p>In a case of <strong>closed</strong> port, it looks slightly differently.</p>
<div class="highlight"><pre><span></span><code><span class="n">Client</span> <span class="o">---</span> <span class="n">SYN</span> <span class="o">---&gt;</span> <span class="n">Server</span>
<span class="n">Client</span> <span class="o">&lt;-</span> <span class="n">RST</span><span class="o">+</span><span class="n">ACK</span> <span class="o">-</span> <span class="n">Server</span>
</code></pre></div>


<p>The server will reply with a packet that has the reset <code>RST</code> and <code>ACK</code> flags set. This behavior tells the client that the port is <strong>closed</strong>.</p>
<p>The simplest way to perform a port scan is trying to connect to every port.</p>
<ul>
<li>if the scanner receives a <code>RST</code> packet, then the port is <strong>closed</strong>.</li>
<li>if the scanner can <strong>complete</strong> 3-way handshake, then the port is <strong>open</strong>. After connecting, the scanner sends an <code>RST</code> packet to the target host to abruptly close the connection.</li>
</ul>
<p>The culprit here is, that every TCP connect is recorded in the daemon logs. Even scans, which often should be stealth. That is because, from the application point of view, the scan probe is legitimate connection.
It allows system administrators to easily detect the scan.</p>
<h3>TCP-SYN scan</h3>
<p>Default usage:</p>
<div class="highlight"><pre><span></span><code><span class="err">nmap -sS &lt;targets&gt;</span>
</code></pre></div>


<p>To mitigate possibility of being detected (in the case of 3-way handshake), there is more stealthy solution, called <code>TCP-SYN scan</code>.
During a SYN scan, the scanner does not perform a full handshake. It just sends a <code>SYN</code> packet and analyzes the response coming from the target machine.</p>
<ul>
<li>if it receives a <code>RST</code> packet, then port is <strong>closed</strong>.</li>
<li>if it receives an <code>ACK</code> packet, then port is <strong>open</strong>. After marking the port as open, the scanner sends a <code>RST</code> packet to the target host to stop the handshake.</li>
</ul>
<p>As there is no full connection to the destination daemon, a <code>SYN</code> scan <strong>cannot be detected</strong> by looking at daemon logs.
It is important to remember, that even <code>TCP-SYN scan</code> can be detected with well-configured IDS (Intrusion Detection System).</p>
<h3>Version detection scan</h3>
<p>Default usage:</p>
<div class="highlight"><pre><span></span><code><span class="err">namp -sV &lt;targets&gt;</span>
</code></pre></div>


<p>This scan is recorded in logs, however it is very useful. It mixes a TCP connect scan with some probes, which are used to detect what application is listening on a particular port.</p>
<div class="highlight"><pre><span></span><code><span class="n">Client</span> <span class="o">---</span> <span class="n">SYN</span> <span class="o">---&gt;</span> <span class="n">Server</span>
<span class="n">Client</span> <span class="o">&lt;-</span> <span class="n">SYN</span><span class="o">+</span><span class="n">ACK</span> <span class="o">-</span> <span class="n">Server</span>
<span class="n">Client</span> <span class="o">---</span> <span class="n">ACK</span> <span class="o">---&gt;</span> <span class="n">Server</span>
<span class="n">Client</span> <span class="o">&lt;-</span> <span class="n">Banner</span> <span class="o">--</span> <span class="n">Server</span>
<span class="n">Client</span> <span class="o">--</span> <span class="n">RST</span><span class="o">+</span><span class="n">ACK</span> <span class="o">&gt;</span> <span class="n">Server</span>
</code></pre></div>


<p>If the daemon doesn't send a banner, <code>nmap</code> sends some probes to understand what the listening application is. It later tries to guess the application based on its behavior.</p>
<h2>Network Discovery with port scanning</h2>
<p>Sometimes, firewall can block pings. In this kind of scenario, typical usage of <code>ping</code> is insufficient. Even if host is not responding to <code>ICMP</code> requests, it oftentimes has some TCP and UDP port opens.
<code>nmap</code> can be forced to scan host which is not responding to <code>ping</code> with <code>-Pn</code>. The scan for common ports like <code>22</code> (ssh), <code>80,443</code> (http/https server), <code>445</code> (samba service) or <code>53</code> (DNS) can reveal that the host is actually "alive" however not responding to <code>ICMP</code>.</p>
<h2>Detecting firewall</h2>
<p>Large networks very often are protected from intrusion by firewalls. It might be difficult to detect firewall, but based on partial or incomplete results of scan, one can identify, that it could be it.
nmap scan with fingerprinting <code>-sV</code> should not have any problems to return full information. Sometimes, however, default information about <code>VERSION</code> could be not present or unrecognized (<code>tcpwrapped</code> means that TCP handshake was completed, but the remote host closed the connection without receiving any data).
To try and see what happened, you might want to use nmap with <code>--reason</code> that will show an explanation of why a port is marked open or closed.</p>
<h2>Masscan</h2>
<p>Masscan was designed to deal with large networks and to scan thousands of IP addresses at once. It is similar to nmap but a lot faster.</p>
<h1>Vulnerability Assessment</h1>
<p>Vulnerability assessment is a scan of the vulnerabilities found on networks and applications. It is faseter and lighter on the infrastructure. As opposed to a penetration test, during a vulnerability assessment, you don't proceed to the exploitation phase.
It means, that after discovering vulnerability, you won't be able to confirm it by testing and giving a proof of exploitation.</p>
<h2>Scanners</h2>
<p>Scanners perform their probes on:</p>
<ul>
<li>daemons listening on TCP and UDP ports</li>
<li>configuration files of operating systems, software suites, network devices, etc.</li>
<li>windows registry entries.</li>
</ul>
<p>The purpose is to find vulnerabilities and misconfigurations.
The better and more up-to-date database of vulnerabilities, the better result of scan.</p>
<p>However, in a case of custom application, a vulnerability scanner may not be enough. In that case, manual test needs to be performed.</p>
<h1>Resources</h1>
<ul>
<li><a href="https://tools.ietf.org/html/rfc792">RFC792 - ICMP</a></li>
<li><a href="https://lcamtuf.coredump.cx/p0f3/">p0f - Website</a></li>
<li><a href="https://en.wikipedia.org/wiki/P0f">p0f - Wiki</a></li>
<li><a href="https://www.openvas.org/">openVAS</a></li>
<li><a href="https://www.rapid7.com/products/nexpose/">Nexpose</a></li>
<li><a href="https://www.gfi.com/products-and-solutions/network-security-solutions/gfi-languard">LanGuard</a></li>
<li><a href="https://www.tenable.com/products/nessus">Nessus</a></li>
</ul>
                <div class="clear"></div>

                <div class="info">
                    <a href="https://blog.smigiel.dev/scanning-network.html">posted at 00:00</a>
                    &nbsp;&middot;
                    &nbsp;<a href="https://blog.smigiel.dev/tag/learning.html" class="tags">learning</a>
                    &nbsp;<a href="https://blog.smigiel.dev/tag/pts.html" class="tags">pts</a>
                    &nbsp;<a href="https://blog.smigiel.dev/tag/scanning.html" class="tags">scanning</a>
                </div>
            </article>            <h4 class="date">Oct 07, 2020</h4>

            <article class="post">
                <h2 class="title">
                    <a href="https://blog.smigiel.dev/osint.html" rel="bookmark" title="Permanent Link to &quot;OSINT&quot;">OSINT</a>
                </h2>

                
                

                <h1>Information gathering</h1>
<p>First and the most crucial phase of an engagement is information gathering. It helps to broaden surface of attack, and prepare for successful method of breaking into company.
Usually, people leave a lot of breadcrumbs around the Internet. Thanks to meticulous look up of the information, a lot of interesting details can be found.</p>
<h2>Interesting databases</h2>
<p>Given the vast array of social networks, it shouldn't be difficult to find interesting information. For example, user can create account on Twitter, point to Linkedin, Google and Facebook.</p>
<p>To find generic information, one might refer to twitter or google. For more work related information, usually better is Linkedin.</p>
<h3>Crunchbase</h3>
<p><a href="https://crunchbase.com">Crunchbase</a> is a platform for finding business information about private and public companies. It is a platform for finding business information about private and public companies. Additionally it contains useful information to match profiles.</p>
<h3>Government websites</h3>
<p>Some information can be found on official government websites. If a company is awarded contract.</p>
<h3>Whois</h3>
<p><code>whois</code> is command line tool, as well as <a href="https://www.whois.com/whois">website</a>. It allows to query the database of Internet addresses to get information about registrants of those addresses.</p>
<h3>Company website</h3>
<p>Oftentimes, interesting information can be found on company websites. We can find there information about products, customers, services, etc. Usually, there could be also find</p>
<h3>Email pattern</h3>
<p>Many companies have common email pattern. It usually means, that all employees, can be reached by some variation of email:</p>
<ul>
<li>first_name.last_name@company.com</li>
<li>last_name.first_name@company.com</li>
<li>first_letter__nameLast_name@company.com</li>
</ul>
<p>By accessing at least one of employees emails, you basically obtained all of them, as long as you know employee name.</p>
<p>To verify if chosen email is valid, one can send email and wait for response. Many email servers return message in the case of non-existing user.</p>
<h2>Subdomain enumeration</h2>
<p>It is common for a company, to have multiple different subdomains, like <code>email.company.com</code>, <code>blog.company.com</code>, <code>careers.company.com</code>. Sometimes, companies leave running vulnerable services. In that case, it could be much easier to exploit a bug on some outdated subdomain, than main domain.
There are several ways of achieving that goal.</p>
<h3>Google</h3>
<p>One of the simplest ways is to search a Google!
By issuing query to search engine like below, we can receive responses focused around particular company website.</p>
<div class="highlight"><pre><span></span><code><span class="n">site</span><span class="o">:</span> <span class="n">company</span><span class="o">.</span><span class="na">com</span>
</code></pre></div>


<h3>dnsdumpster</h3>
<p><a href="https://dnsdumpster.com/">DNSDumpster.com</a> is a free domain research tool that can discover hosts related to a domain. Finding visible hosts from the attackers perspective is an important part of the security assessment process.</p>
<h3>CLI Sublist3r</h3>
<p>Sublist3r is a python tool designed to enumerate subdomains of websites using OSINT. It helps penetration testers and bug hunters collect and gather subdomains for the domain they are targeting. Sublist3r enumerates subdomains using many search engines such as Google, Yahoo, Bing, Baidu and Ask. Sublist3r also enumerates subdomains using Netcraft, Virustotal, ThreatCrowd, DNSdumpster and ReverseDNS.</p>
<h1>Additional resources</h1>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Crunchbase">Crunchbase - wikipedia</a></li>
<li><a href="https://www.sam.gov/SAM/">System for Award Management (US gov)</a></li>
<li><a href="https://www.gsaelibrary.gsa.gov/ElibMain/home.do">GSA eLibrary - contract award information (US gov)</a></li>
<li><a href="https://dnsdumpster.com/">DNSDumpster.com</a></li>
<li><a href="https://github.com/aboul3la/Sublist3r">CLI Sublist3r</a></li>
<li><a href="https://crt.sh/">crt.sh - certificate search</a></li>
<li><a href="https://github.com/OWASP/Amass">OWASP Amass</a></li>
</ul>
                <div class="clear"></div>

                <div class="info">
                    <a href="https://blog.smigiel.dev/osint.html">posted at 00:00</a>
                    &nbsp;&middot;
                    &nbsp;<a href="https://blog.smigiel.dev/tag/learning.html" class="tags">learning</a>
                    &nbsp;<a href="https://blog.smigiel.dev/tag/pts.html" class="tags">pts</a>
                    &nbsp;<a href="https://blog.smigiel.dev/tag/osint.html" class="tags">osint</a>
                </div>
            </article>            <h4 class="date">Oct 01, 2020</h4>

            <article class="post">
                <h2 class="title">
                    <a href="https://blog.smigiel.dev/web-applications.html" rel="bookmark" title="Permanent Link to &quot;Web Applications&quot;">Web Applications</a>
                </h2>

                
                

                <h1>Basics</h1>
<p>During building web applications we need to focus on several fundamental aspects:</p>
<ol>
<li>HTTP Protocol Basics</li>
<li>Cookies</li>
<li>Sessions</li>
<li>Same Origin Policy</li>
</ol>
<h2>HTTP Protocol Basics</h2>
<p><code>HTTP</code> (Hypertext Transfer Protocol) is the most used protocol on the Internet. Usually, the client (browser), connects to the server (<code>Apache</code>, <code>nginx</code>, <code>ISS</code>.
During an HTTP communication, the client and the server exchange messages. HTTP works on top of TCP. That means, first a TCP connection is established, and then the client sends its request, and waits for the answer. The server processes the request and sends back its answer, providing a status code and appropriate data.</p>
<h3>HTTP Request</h3>
<p>To send HTTP request, usually we use browsers. However, it is not the only way of doing so. To build request, we can use <code>netcat</code> or <code>telnet</code>.
Below is an example of HTTP request, with <code>nc</code> requesting website running on localhost on port <code>8000</code>.</p>
<div class="highlight"><pre><span></span><code>$ nc localhost 8000
GET / HTTP/1.0
Host: localhost

HTTP/1.0 200 OK
Server: SimpleHTTP/0.6 Python/3.7.3
Date: Fri, 02 Oct 2020 01:44:49 GMT
Content-type: text/html
Content-Length: 26612
Last-Modified: Fri, 02 Oct 2020 01:44:33 GMT

<span class="cp">&lt;!DOCTYPE html&gt;</span>
[...]
</code></pre></div>


<p>First line contains <strong>HTTP request method</strong>, path and protocol version.
HTTP request method is information about the type of the request. Other requests are: <code>PUT</code>, <code>POST</code>, <code>HEAD</code>, etc. List of available metods can be found on <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">Mozilla website</a>
Path tells the server which resource to fetch, while protocol version tells how to communicate with the client.
Next, there is <code>Host</code> header field, which specifies the Internet hostname and port number of the resource being requested.</p>
<p>We can also create one-liner to retrieve appropriate information</p>
<div class="highlight"><pre><span></span><code>$ <span class="nb">echo</span> -en <span class="s1">&#39;HEAD / HTTP/1.1\r\nHost:localhost\r\n\r\n&#39;</span> <span class="p">|</span> nc localhost <span class="m">8000</span>
HTTP/1.0 <span class="m">200</span> OK
Server: SimpleHTTP/0.6 Python/3.7.3
Date: Fri, <span class="m">02</span> Oct <span class="m">2020</span> <span class="m">02</span>:01:34 GMT
Content-type: text/html
Content-Length: <span class="m">27806</span>
Last-Modified: Fri, <span class="m">02</span> Oct <span class="m">2020</span> <span class="m">01</span>:55:46 GMT
</code></pre></div>


<p>Additionally, we can give extra header values like <code>User-Agent</code> (identifies the client and the system), <code>Accept</code> (specifies document type the client is expecting in the response) or <code>Connection: keep-alive</code> (future communications with the server will reuse the current connection).</p>
<h3>HTTP Response</h3>
<p>HTTP response, similar to request, has common format.</p>
<div class="highlight"><pre><span></span><code>$ nc localhost 8000
GET / HTTP/1.0
Host: localhost

HTTP/1.0 200 OK
Server: SimpleHTTP/0.6 Python/3.7.3
Date: Fri, 02 Oct 2020 01:44:49 GMT
Content-type: text/html
Content-Length: 26612
Last-Modified: Fri, 02 Oct 2020 01:44:33 GMT

<span class="cp">&lt;!DOCTYPE html&gt;</span>
[...]
</code></pre></div>


<p>The first line is <strong>Status-Line</strong> which consists of protocol version (HTTP 1.0) followed by a numeric status code (200) and textual meaning (OK). There are many codes. Description, again can be found on <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">Mozilla website</a>. Next, there is additional information regarding server, date and time at which the message was originated, followed by page content.</p>
<h3>HTTP Secure (HTTPS)</h3>
<p>HTTP over SSL/TLS is a method to run clear-text HTTP with extra cryptographic protocol, to prevent from sniffing.
By doing so, entire traffic is being encrypted. It means, that even if someone can intercept traffic, they won't be able to see what kind of information is being transmitted. The only non-encrypted pieces of information would be:</p>
<ul>
<li>target IP address</li>
<li>target port</li>
<li>DNS or similar protocols (domain resolvers)</li>
</ul>
<p>To analyze connection, we cannot use <code>nc</code> anymore, which doesn't support SSL. To work with SSL, we can use <code>openssl</code></p>
<div class="highlight"><pre><span></span><code>$ nc blog.smigiel.dev <span class="m">443</span>
HEAD / HTTP/1.1
$
</code></pre></div>


<div class="highlight"><pre><span></span><code>$ openssl s_client -connect blog.smigiel.dev:443 -quiet
<span class="nv">depth</span><span class="o">=</span><span class="m">2</span> <span class="nv">O</span> <span class="o">=</span> Digital Signature Trust Co., <span class="nv">CN</span> <span class="o">=</span> DST Root CA X3
verify <span class="k">return</span>:1
<span class="nv">depth</span><span class="o">=</span><span class="m">1</span> <span class="nv">C</span> <span class="o">=</span> US, <span class="nv">O</span> <span class="o">=</span> Let<span class="s1">&#39;s Encrypt, CN = Let&#39;</span>s Encrypt Authority X3
verify <span class="k">return</span>:1
<span class="nv">depth</span><span class="o">=</span><span class="m">0</span> <span class="nv">CN</span> <span class="o">=</span> blog.smigiel.dev
verify <span class="k">return</span>:1
HEAD / HTTP/1.1
Host: blog.smigiel.dev

HTTP/1.1 <span class="m">200</span> OK
Connection: keep-alive
Content-Length: <span class="m">30082</span>
Server: GitHub.com
Content-Type: text/html<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>utf-8
Last-Modified: Wed, <span class="m">30</span> Sep <span class="m">2020</span> <span class="m">03</span>:07:04 GMT
ETag: <span class="s2">&quot;5f73f658-7582&quot;</span>
Access-Control-Allow-Origin: *
Expires: Fri, <span class="m">02</span> Oct <span class="m">2020</span> <span class="m">01</span>:14:17 GMT
Cache-Control: max-age<span class="o">=</span><span class="m">600</span>
X-Proxy-Cache: MISS
X-GitHub-Request-Id: 376E:4248:1F613:26B71:5F767C91
Accept-Ranges: bytes
Date: Fri, <span class="m">02</span> Oct <span class="m">2020</span> <span class="m">02</span>:57:10 GMT
Via: <span class="m">1</span>.1 varnish
Age: <span class="m">49</span>
X-Served-By: cache-pao17443-PAO
X-Cache: HIT
X-Cache-Hits: <span class="m">1</span>
X-Timer: S1601607430.114992,VS0,VE1
Vary: Accept-Encoding
X-Fastly-Request-ID: b902c4a5a2f4410e8e6ac21e60fa2e659f1e8300
</code></pre></div>


<h2>HTTP Cookies</h2>
<p>HTTP is stateless protocol. It means, that website cannot keep the state of a visit across different HTTP requests. Every HTTP request is unrelated to others.
To change this situation, <a href="https://en.wikipedia.org/wiki/HTTP_cookie">cookies</a> were introduced.</p>
<p>Cookies are textual information installed by a website into web browser. Server can set a cookie using <strong>Set-Cookie</strong> header field.</p>
<h3>Cookie fields</h3>
<p>Cookies are only sent to the valid domain and path when they are not expired and according to their flags.
The domain field and the path field set the scope of the cookie. The browser sends the cookie only if the request is for the right domain.
If the server does not specify domain attribute, the browser will automatically set the domain as the server domain and set the cookie <strong>host-only</strong> flag. It means that the cookie will be sent only to that precise hostname.</p>
<h3>Cookie protocol</h3>
<p>Cookies are usually set during a login. Browser sends <strong>POST</strong> request to the server, and the server responds with a <strong>Set-Cookie</strong> header field.
For every subsequent request, the browser considers domain, path, expiration and flags. If all checks pass, the browser will insert a <strong>cookie:</strong> header in the request.</p>
<h2>Sessions</h2>
<p>Sessions mechanism works similar to cookies. The difference here relies on the way how the information is stored. Session is kept on <em>server-side</em>. Each user session is identified by a <strong>session id</strong> which the server assigns to the user. The client then presents its <strong>ID</strong> for each subsequent request, thus being recognized by the server. The server retrieves the state of the client and all its associated variables.</p>
<h2>Same-Origin Policy (SOP)</h2>
<p>Same-Origin Policy prevents JavaScript code from getting or setting properties on a resource comming from a <strong>different origin</strong>. To determine if JavaScript can access a resource <em>hostname</em>, <em>port</em> and <em>protocol</em> must match.
SOP applies only to the actual code. It is still possible to include external resources by other HTML tags like <code>img</code>, <code>script</code>, <code>iframe</code>, <code>object</code>, etc.</p>
<h1>Additional resources</h1>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">HTTP request methods</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">HTTP response status codes - Mozilla</a></li>
<li><a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">HTTP response status codes - Wikipedia</a></li>
<li><a href="http://www.tcpipguide.com/free/t_HTTPOverviewHistoryVersionsandStandards.htm">HTTP Overview, history, versions, standards</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies">HTTP Cookie - Mozilla</a></li>
<li><a href="https://en.wikipedia.org/wiki/HTTP_cookie">HTTP Cookie - Wikipedia</a></li>
<li><a href="https://tools.ietf.org/html/rfc6265">HTTP State management mechanism - RFC6265</a></li>
</ul>
                <div class="clear"></div>

                <div class="info">
                    <a href="https://blog.smigiel.dev/web-applications.html">posted at 00:00</a>
                    &nbsp;&middot;
                    &nbsp;<a href="https://blog.smigiel.dev/tag/learning.html" class="tags">learning</a>
                    &nbsp;<a href="https://blog.smigiel.dev/tag/pts.html" class="tags">pts</a>
                    &nbsp;<a href="https://blog.smigiel.dev/tag/http.html" class="tags">http</a>
                </div>
            </article>            <h4 class="date">Sep 23, 2020</h4>

            <article class="post">
                <h2 class="title">
                    <a href="https://blog.smigiel.dev/networking-pt-4.html" rel="bookmark" title="Permanent Link to &quot;Networking Pt 4&quot;">Networking Pt 4</a>
                </h2>

                
                

                <h1>Firewall</h1>
<p>Firewalls are specialized software modules running on a computer or a dedicated network device. They serve to filter packets coming in and out of a network. They can work on different layers of the OSI model.</p>
<h2>Packet filtering</h2>
<p>The most basic feature of a firewall is packet filtering. Administrator can create rules which will filter packets according to certain characteristics like:</p>
<ul>
<li>source IP address</li>
<li>destination IP address</li>
<li>protocol</li>
<li>source port</li>
<li>destination port</li>
</ul>
<p>Common actions, that can be applied:</p>
<ul>
<li>allow: allow the packet to pass</li>
<li>drop: drops the packet without any diagnostic message to the packet source host</li>
<li>deny: similar to drop, but notify the source host</li>
</ul>
<p>Inspecting the header of a packet does not give you any information on the content. Even if only port <code>80</code> or <code>443</code> is allowed, attacker can exploit them, to access deeper levels of network.</p>
<h2>Application level firewalls</h2>
<p>Application level firewall works by checking all 7 layers of the OSI model. They provide more comprehensive protection because they inspect the actual content of a packet, not just headers.</p>
<h2>Intrusion Detection System (IDS)</h2>
<p>IDS inspects the application payload trying to detect any potential attack. It checks for attack vectors like ping sweeps, port scans, SQL injections, buffer overflows etc.
IDS, similar to antivirus, detects risky traffic by means of signatures. The vendor provides frequent signature updates as soon as new attack vectors are found. Without the right signatures an IDS cannot detect and report an intrusion.
There is also risk of <strong>false positives</strong> when legic traffic is marked as malicious.</p>
<p><code>IDS != firewall</code>
IDS is another layer of protection, which can be used in conjunction with firewall.</p>
<h2>Intrusion Prevention System (IPS)</h2>
<p>It is similar to IDS, however it can drop malicious request when the threat has risk classification above predefined threshold.</p>
<h1>Domain Name System (DNS)</h1>
<p>The DNS converts human-readable names to IP addresses.
DNS structure can be broken down into:</p>
<ul>
<li>top level domain (TLD)</li>
<li>domain part</li>
<li>subdomain part (if applicable)</li>
<li>host part</li>
</ul>
<p>Name resolution is performed by resolvers. Resolvers are servers that contact the TLD server and follow the hierarchy of the DNS name to resolve the name of a host:</p>
<ol>
<li>resolver contacts one of the <strong>root name servers</strong>, these server contain information about the TLD (this information is hardcoded by system administrator);</li>
<li>next, it asks the TLD name server (from previous step), what's the name of the server which can give information about the <strong>domain</strong> the resolver is looking for;</li>
<li>if there are one or more subdomains, previous step is repeated for every subdomain;</li>
<li>resolver asks for the name resolution of the <strong>host</strong> part;</li>
<li>the resolver sends the IP address back to the client.</li>
</ol>
                <div class="clear"></div>

                <div class="info">
                    <a href="https://blog.smigiel.dev/networking-pt-4.html">posted at 00:00</a>
                    &nbsp;&middot;
                    &nbsp;<a href="https://blog.smigiel.dev/tag/learning.html" class="tags">learning</a>
                    &nbsp;<a href="https://blog.smigiel.dev/tag/pts.html" class="tags">pts</a>
                    &nbsp;<a href="https://blog.smigiel.dev/tag/network.html" class="tags">network</a>
                </div>
            </article>

                <div class="clear"></div>
                <div class="pages">


                    <a href="https://blog.smigiel.dev/author/dasm2.html" class="next_page">Next&nbsp;&rarr;</a>

                    <span>Page 1 of 3</span>
                </div>

            <div class="clear"></div>
            <footer>
                <p>
                <a href="https://github.com/jody-frankowski/blue-penguin">Blue Penguin</a> Theme
                &middot;
                Powered by <a href="http://getpelican.com">Pelican</a>
                &middot;
                <a href="https://blog.smigiel.dev/feeds/all.atom.xml" rel="alternate">Atom Feed</a>
            </footer>
        </div>
        <div class="clear"></div>
    </div>
</body>
</html>